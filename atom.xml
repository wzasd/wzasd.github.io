<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeffrey for it</title>
  <subtitle>Although the turnaround or salted fish, but at least can become a bit tasty</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-06T06:25:03.053Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jeffrey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Andriod-Rx系列(一)</title>
    <link href="http://yoursite.com/2017/02/06/Android-rx%E7%B3%BB%E5%88%97(1)/"/>
    <id>http://yoursite.com/2017/02/06/Android-rx系列(1)/</id>
    <published>2017-02-06T14:22:01.000Z</published>
    <updated>2017-02-06T06:25:03.053Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/rx.png" alt="redux"></p>
<h2 id="学习Rx系列就从概念开始"><a href="#学习Rx系列就从概念开始" class="headerlink" title="学习Rx系列就从概念开始"></a>学习Rx系列就从概念开始</h2><h3 id="什么是响应式编程？"><a href="#什么是响应式编程？" class="headerlink" title="什么是响应式编程？"></a>什么是响应式编程？</h3><blockquote>
<p> 响应式编程其实可以称之为编程范式，从古到今的命令式编程，面向对象编程，函数式编程，都是为了解决当前的问题，现在更新到响应式编程。</p>
</blockquote>
<h4 id="响应式编程的几个特点"><a href="#响应式编程的几个特点" class="headerlink" title="响应式编程的几个特点"></a>响应式编程的几个特点</h4><ul>
<li>响应式：总是可以相应用户的请求</li>
<li>弹性：部分组件出现问题也可以进行响应不会全部瘫痪</li>
<li>可伸缩性：根据需求的实际情况进行响应，增加资源</li>
<li>消息驱动：是通过数据流进行消息驱动<h4 id="响应式流"><a href="#响应式流" class="headerlink" title="响应式流"></a>响应式流</h4></li>
</ul>
<p>响应式流含义就比较简单了</p>
<ul>
<li>发布者：事件发送者</li>
<li>订阅者：事件订阅者</li>
<li>订阅：发布者和订阅者的联系人</li>
</ul>
<p>最重要的一点：使用响应式编程来思考问题，不再像以前命令或者函数式驱动，最重要的是数据流的概念！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/rx.png&quot; alt=&quot;redux&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;学习Rx系列就从概念开始&quot;&gt;&lt;a href=&quot;#学习Rx系列就从概念开始&quot; class=&quot;headerlink&quot; title=&quot;学习Rx系列就从概念开始&quot;&gt;&lt;/a&gt;学习Rx
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>不算总结的总结</title>
    <link href="http://yoursite.com/2017/01/04/2016%E4%B8%8D%E7%AE%97%E6%80%BB%E7%BB%93%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/01/04/2016不算总结的总结/</id>
    <published>2017-01-03T17:56:58.000Z</published>
    <updated>2017-01-03T10:01:32.843Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/winde.jpg" alt="冬天"><br>其实早就想写关于2016年的总结，但是懒癌毕竟是难治一直没有写，况且年终受到了惊吓，如今终于平复，希望可以平平常常写下这年终总结。</p>
<p>事情就像是一篇没有写完的代码，框架已经打好，只是内容繁琐又复杂，本就没有头绪这就又增添一种神秘感，那就由近到远的诉说好了。</p>
<p>应该记录的是公司年会，从没想到来到一个公司不到一个月的时间，能这么融洽的融到公司里面，和这个team有不可脱离的关系，不说工作，氛围满分。不知道多久多久，或者从未有过跟一个朋友能聊一个晚上，我是有多么惊讶，如此的热情，也就你能拥有了，我想这就是所谓的感染力，从Breakdown到Excitation，这种可能性被无限的放大，It’s amazing，但是这才是真的你不是吗？有两个词倒是让我记到现在，bitch and Stronger mate. 这是一个神奇的称呼，也是不同的自己的体现不是吗？Just do it!Whether successful or not,who care?</p>
<p>来到公司前也同样有一种生活，也许今年的波折有一点多，突然有一种爆炸的感觉，从一个被称之为天堂的地方，另外一个朝九晚五的地方，跳出来，需要多大的勇气？原来曾经自己也是一个挺安稳安逸的样子，有时候会觉得安稳是一种幸福，但是为什么又是那么不安呢？太着急总是令人烦躁，尽人事，知天命，若是人事都没有尽如何而来知天命呢？我们都辜负了自己而已，所有的苦难并不是我遇到的会让我多么狼狈，而是我辜负了自己。罢了，哪怕是咸鱼，也要翻一下，这样才会更加美味不是吗？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/winde.jpg&quot; alt=&quot;冬天&quot;&gt;&lt;br&gt;其实早就想写关于2016年的总结，但是懒癌毕竟是难治一直没有写，况且年终受到了惊吓，如今终于平复，希望可以平平常常写下这年终总结。&lt;/p&gt;
&lt;p&gt;事情就像是一篇没有写完的代码，框架已经打好，
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>从零开始React项目(一)</title>
    <link href="http://yoursite.com/2017/01/03/MarketSmithWeb%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2017/01/03/MarketSmithWeb架构设计/</id>
    <published>2017-01-03T13:45:40.000Z</published>
    <updated>2017-01-03T10:03:58.106Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/redux.png" alt="redux"><br>进入Williamoneil已经有近一个月了，项目基本落地，Web端框架的技术选型也已完备，记录一下自己做的努力，然后以备以后项目需要，可以快速开始而且，并持续根据自己的知识储备进行优化。</p>
<a id="more"></a>
<h3 id="项目结构的设计"><a href="#项目结构的设计" class="headerlink" title="项目结构的设计"></a>项目结构的设计</h3><pre><code>build
|-- webpack.config.js               # 公共配置
|-- webpack.dev.js                  # 开发配置
|-- webpack.release.js              # 发布配置
docs                                # 项目文档
node_modules                        
src                                 # 项目源码
|-- actions                            # redux Action组件
|-- components                        # react Comonents组件
|-- constants                        # react Containers组件
|-- conf                            # 配置文件
|-- services                        # 服务api
|-- fonts                             # 字体
|-- components                      # 组件目录
|   |-- loading
|   |   |-- index.js
|   |   |-- index.scss
|   |   |-- __tests__               
|   |   |   |-- xx.js
|-- actions
|   |   |-- index.js
|   |   |-- __tests__               
|   |   |   |-- xx.js
|-- reducers 
|   |-- index.js
|   |-- __tests__               
|   |   |-- xx.js
|   |-- xx.js 
|-- styles                             # 公共CSS目录
|   |-- common.scss
|-- img                             # 公共图片目录
|   |-- xx.png
tests                               # 其他测试文件
app.html                    # 入口页
app.js                      # 入口JS
package.json                        
READNE.md
</code></pre><h3 id="要完成的任务"><a href="#要完成的任务" class="headerlink" title="要完成的任务"></a>要完成的任务</h3><ol>
<li>编译 jsx、es6、scss 等资源编译 </li>
<li>自动引入静态资源到相应 html 页面</li>
<li>实时编译和刷新浏览器</li>
<li>按指定模块化规范自动包装模块</li>
<li>自动给 css 添加浏览器内核前缀</li>
<li>按需打包合并 js、css</li>
<li>压缩 js、css、html</li>
<li>图片路径处理、压缩、CssSprite</li>
<li>对文件使用 hash 命名，做强缓存</li>
<li>语法检查</li>
<li>全局替换指定字符串</li>
<li>本地接口模拟服务</li>
</ol>
<h3 id="本文使用的boilerplate，项目地址：webpack-react-redux-es6-boilerplate，在此基础上，增添了自己的需求，适合本项目。"><a href="#本文使用的boilerplate，项目地址：webpack-react-redux-es6-boilerplate，在此基础上，增添了自己的需求，适合本项目。" class="headerlink" title="本文使用的boilerplate，项目地址：webpack-react-redux-es6-boilerplate，在此基础上，增添了自己的需求，适合本项目。"></a>本文使用的boilerplate，项目地址：<a href="https://github.com/xiaoyann/webpack-react-redux-es6-boilerplate" target="_blank" rel="external">webpack-react-redux-es6-boilerplate</a>，在此基础上，增添了自己的需求，适合本项目。</h3><h3 id="根据webpack文档，编写webpack配置，并且使用NODE-API的方式"><a href="#根据webpack文档，编写webpack配置，并且使用NODE-API的方式" class="headerlink" title="根据webpack文档，编写webpack配置，并且使用NODE API的方式"></a>根据<a href="http://webpack.github.io/docs/" target="_blank" rel="external">webpack</a>文档，编写webpack配置，并且使用NODE API的方式</h3><pre><code>/* webpack.config.js */

var webpack = require(&apos;webpack&apos;);

// 辅助函数
var utils = require(&apos;./utils&apos;);
var fullPath  = utils.fullPath;
var pickFiles = utils.pickFiles;

// 项目根路径
var ROOT_PATH = fullPath(&apos;../&apos;);
// 项目源码路径
var SRC_PATH = ROOT_PATH + &apos;/src&apos;;
// 产出路径
var DIST_PATH = ROOT_PATH + &apos;/dist&apos;;

// 是否是开发环境
var __DEV__ = process.env.NODE_ENV !== &apos;production&apos;;

// conf
var alias = pickFiles({
  id: /(conf\/[^\/]+).js$/,
  pattern: SRC_PATH + &apos;/conf/*.js&apos;
});

// components
alias = Object.assign(alias, pickFiles({
  id: /(components\/[^\/]+)/,
  pattern: SRC_PATH + &apos;/components/*/index.js&apos;
}));

// reducers
alias = Object.assign(alias, pickFiles({
  id: /(reducers\/[^\/]+).js/,
  pattern: SRC_PATH + &apos;/js/reducers/*&apos;
}));

// actions
alias = Object.assign(alias, pickFiles({
  id: /(actions\/[^\/]+).js/,
  pattern: SRC_PATH + &apos;/js/actions/*&apos;
}));


var config = {
  context: SRC_PATH,
  entry: {
    app: [&apos;./pages/app.js&apos;]
  },
  output: {
    path: DIST_PATH,
    filename: &apos;js/bundle.js&apos;
  },
  module: {},
  resolve: {
    alias: alias
  },
  plugins: [
    new webpack.DefinePlugin({
      // http://stackoverflow.com/questions/30030031/passing-environment-dependent-variables-in-webpack
      &quot;process.env.NODE_ENV&quot;: JSON.stringify(process.env.NODE_ENV || &apos;development&apos;)
    })
  ]
};

module.exports = config;
</code></pre><hr>
<pre><code>/* webpack.dev.js */

var webpack = require(&apos;webpack&apos;);
var WebpackDevServer = require(&apos;webpack-dev-server&apos;);
var config = require(&apos;./webpack.config&apos;);
var utils = require(&apos;./utils&apos;);

var PORT = 8080;
var HOST = utils.getIP();
var args = process.argv;
var hot = args.indexOf(&apos;--hot&apos;) &gt; -1;
var deploy = args.indexOf(&apos;--deploy&apos;) &gt; -1;

// 本地环境静态资源路径
var localPublicPath = &apos;http://&apos; + HOST + &apos;:&apos; + PORT + &apos;/&apos;;

config.output.publicPath = localPublicPath; 
config.entry.app.unshift(&apos;webpack-dev-server/client?&apos; + localPublicPath);

new WebpackDevServer(webpack(config), {
  hot: hot,
  inline: true,
  compress: true,
  stats: {
    chunks: false,
    children: false,
    colors: true
  },
  // Set this as true if you want to access dev server from arbitrary url.
  // This is handy if you are using a html5 router.
  historyApiFallback: true,
}).listen(PORT, HOST, function() {
  console.log(localPublicPath);
});
</code></pre><p>配置好就可以开始构建了</p>
<pre><code>$ node build/webpack.dev.js
</code></pre><p>因为项目中使用了 jsx、es6、scss，所以还要添加相应的 loader，否则会报如下类似错误：</p>
<pre><code>ERROR in ./src/pages/app.js
Module parse failed: /Users/xiaoyan/working/webpack-react-redux-es6-boilerplate/src/pages/app.js Unexpected token (18:6)
You may need an appropriate loader to handle this file type.
</code></pre><p>编译 jsx、es6、scss 等资源</p>
<ul>
<li>使用 <a href="http://babeljs.io/" target="_blank" rel="external">bael</a> 和 <a href="https://github.com/babel/babel-loader" target="_blank" rel="external">babel-loader</a> 编译 jsx、es6</li>
<li>安装插件: <a href="http://babeljs.io/docs/plugins/preset-es2015/" target="_blank" rel="external">babel-preset-es2015</a> 用于解析 es6</li>
<li><p>安装插件：<a href="http://babeljs.io/docs/plugins/preset-react/" target="_blank" rel="external">babel-preset-react</a> 用于解析 jsx</p>
<pre><code>// 首先需要安装 babel 
$ npm i babel-core --save-dev
// 安装插件 
$ npm i babel-preset-es2015 babel-preset-react --save-dev
// 安装 loader
$ npm i babel-loader --save-dev
</code></pre></li>
</ul>
<p>在项目根目录创建 <code>.babelrc</code> 文件:</p>
<pre><code>{
  &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;]
}
</code></pre><p>在 webpack.config.js 里添加：</p>
<pre><code>// 使用缓存
var CACHE_PATH = ROOT_PATH + &apos;/cache&apos;;
// loaders
config.module.loaders = [];
// 使用 babel 编译 jsx、es6
config.module.loaders.push({
  test: /\.js$/,
  exclude: /node_modules/,
  include: SRC_PATH,
  // 这里使用 loaders ，因为后面还需要添加 loader
  loaders: [&apos;babel?cacheDirectory=&apos; + CACHE_PATH]
});
</code></pre><p>接下来使用 sass-loader 编译 sass:</p>
<pre><code>$ npm i sass-loader node-sass css-loader style-loader --save-dev
</code></pre><ul>
<li><a href="https://github.com/webpack/css-loader" target="_blank" rel="external">css-loader</a> 用于将 css 当做模块一样来 import</li>
<li><a href="https://github.com/webpack/style-loader" target="_blank" rel="external">style-loader</a> 用于自动将 css 添加到页面</li>
</ul>
<p>在 webpack.config.js 里添加：</p>
<pre><code>// 编译 sass
config.module.loaders.push({
  test: /\.(scss|css)$/,
  loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;]
});
</code></pre><h3 id="自动引入静态资源到相应-html-页面"><a href="#自动引入静态资源到相应-html-页面" class="headerlink" title="自动引入静态资源到相应 html 页面"></a>自动引入静态资源到相应 html 页面</h3><ul>
<li><p>使用 <a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin</a></p>
<pre><code>$ npm i html-webpack-plugin --save-dev
</code></pre></li>
</ul>
<p>在 webpack.config.js 里添加：</p>
<pre><code>// html 页面
var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;);
config.plugins.push(
  new HtmlwebpackPlugin({
    filename: &apos;index.html&apos;,
    chunks: [&apos;app&apos;],
    template: SRC_PATH + &apos;/pages/app.html&apos;
  })
);
</code></pre><p>至此，整个项目就可以正常跑起来了</p>
<pre><code>$ node build/webpack.dev.js
</code></pre><h3 id="实时编译和刷新浏览器"><a href="#实时编译和刷新浏览器" class="headerlink" title="实时编译和刷新浏览器"></a>实时编译和刷新浏览器</h3><p>完成前面的配置后，项目就已经可以实时编译和自动刷新浏览器了。接下来就配置下热更新，使用 <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="external">react-hot-loader</a>：</p>
<pre><code>$ npm i react-hot-loader --save-dev
</code></pre><p>因为热更新只需要在开发时使用，所以在 webpack.dev.config 里添加如下代码：</p>
<pre><code>// 开启热替换相关设置
if (hot === true) {
      config.entry.app.unshift(&apos;webpack/hot/only-dev-server&apos;);
      // 注意这里 loaders[0] 是处理 .js 文件的 loader
      config.module.loaders[0].loaders.unshift(&apos;react-hot&apos;);
      config.plugins.push(new webpack.HotModuleReplacementPlugin());
}
</code></pre><p>执行下面的命令，并尝试更改 js、css：</p>
<pre><code>$ node build/webpack.dev.js --hot
</code></pre><h3 id="自动给-css-添加浏览器内核前缀"><a href="#自动给-css-添加浏览器内核前缀" class="headerlink" title="自动给 css 添加浏览器内核前缀"></a>自动给 css 添加浏览器内核前缀</h3><p>使用 <a href="https://github.com/postcss/postcss-loader" target="_blank" rel="external">postcss-loader</a></p>
<pre><code>npm i postcss-loader precss autoprefixer --save-dev
</code></pre><p>在 webpack.config.js 里添加：</p>
<pre><code>// 编译 sass
config.module.loaders.push({
  test: /\.(scss|css)$/,
  loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;, &apos;postcss&apos;]
});

// css autoprefix
var precss = require(&apos;precss&apos;);
var autoprefixer = require(&apos;autoprefixer&apos;);
config.postcss = function() {
  return [precss, autoprefixer];
}
</code></pre><h3 id="打包合并-js、css"><a href="#打包合并-js、css" class="headerlink" title="打包合并 js、css"></a>打包合并 js、css</h3><p>webpack 默认将所有模块都打包成一个 bundle，并提供了 <a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Code Splitting</a> 功能便于我们按需拆分。在这个例子里我们把框架和库都拆分出来：</p>
<p>在 webpack.config.js 添加：</p>
<pre><code>config.entry.lib = [
  &apos;react&apos;, &apos;react-dom&apos;, &apos;react-router&apos;,
  &apos;redux&apos;, &apos;react-redux&apos;, &apos;redux-thunk&apos;
]

config.output.filename = &apos;js/[name].js&apos;;

config.plugins.push(
    new webpack.optimize.CommonsChunkPlugin(&apos;lib&apos;, &apos;js/lib.js&apos;)
);

// 别忘了将 lib 添加到 html 页面
// chunks: [&apos;app&apos;, &apos;lib&apos;]
</code></pre><p>如何拆分 CSS：<a href="http://webpack.github.io/docs/stylesheets.html" target="_blank" rel="external">separate css bundle</a></p>
<h3 id="压缩-js、css、html、png-图片"><a href="#压缩-js、css、html、png-图片" class="headerlink" title="压缩 js、css、html、png 图片"></a>压缩 js、css、html、png 图片</h3><p>压缩资源最好只在生产环境时使用</p>
<p>// 压缩 js、css<br>config.plugins.push(<br>    new webpack.optimize.UglifyJsPlugin({<br>        compress: {<br>            warnings: false<br>        }<br>    })<br>);</p>
<pre><code>// 压缩 html
// html 页面
var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;);
config.plugins.push(
  new HtmlwebpackPlugin({
    filename: &apos;index.html&apos;,
    chunks: [&apos;app&apos;, &apos;lib&apos;],
    template: SRC_PATH + &apos;/pages/app.html&apos;,
    minify: {
      collapseWhitespace: true,
      collapseInlineTagWhitespace: true,
      removeRedundantAttributes: true,
      removeEmptyAttributes: true,
      removeScriptTypeAttributes: true,
      removeStyleLinkTypeAttributes: true,
      removeComments: true
    }
  })
);
</code></pre><h3 id="图片路径处理、压缩、CssSprite"><a href="#图片路径处理、压缩、CssSprite" class="headerlink" title="图片路径处理、压缩、CssSprite"></a>图片路径处理、压缩、CssSprite</h3><ul>
<li>压缩图片使用 <a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="external">image-webpack-loader</a></li>
<li><p>图片路径处理使用 <a href="https://github.com/webpack/url-loader" target="_blank" rel="external">url-loader</a></p>
<p>  $ npm i url-loader image-webpack-loader –save-dev</p>
</li>
</ul>
<p>在 webpack.config.js 里添加：</p>
<pre><code>// 图片路径处理，压缩
config.module.loaders.push({
  test: /\.(?:jpg|gif|png|svg)$/,
  loaders: [
    &apos;url?limit=8000&amp;name=img/[hash].[ext]&apos;,
    &apos;image-webpack&apos;
  ]
});
</code></pre><p>雪碧图处理：<a href="http://kyon-df.com/2016/03/16/webpack" target="_blank" rel="external">webpackautosprites</a></p>
<h3 id="对文件使用-hash-命名，做强缓存"><a href="#对文件使用-hash-命名，做强缓存" class="headerlink" title="对文件使用 hash 命名，做强缓存"></a>对文件使用 hash 命名，做强缓存</h3><p>根据 <a href="http://webpack.github.io/docs/long-term-caching.html" target="_blank" rel="external">docs</a>，在产出文件命名中加上 <code>[hash]</code></p>
<pre><code>config.output.filename = &apos;js/[name].[hash].js&apos;;
</code></pre><h3 id="本地接口模拟服务"><a href="#本地接口模拟服务" class="headerlink" title="本地接口模拟服务"></a>本地接口模拟服务</h3><pre><code>// 直接使用 epxress 创建一个本地服务
$ npm install epxress --save-dev
$ mkdir mock &amp;&amp; cd mock
$ touch app.js

var express = require(&apos;express&apos;);
var app = express();

// 设置跨域访问，方便开发
app.all(&apos;*&apos;, function(req, res, next) {
res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
next();
});

// 具体接口设置
app.get(&apos;/api/test&apos;, function(req, res) {
res.send({ code: 200, data: &apos;your data&apos; });
});

var server = app.listen(3000, function() {
var host = server.address().address;
var port = server.address().port;
console.log(&apos;Mock server listening at http://%s:%s&apos;, host, port);
});
// 启动服务，如果用 PM2 管理会更方便，增加接口不用自己手动重启服务
$ node app.js &amp;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/redux.png&quot; alt=&quot;redux&quot;&gt;&lt;br&gt;进入Williamoneil已经有近一个月了，项目基本落地，Web端框架的技术选型也已完备，记录一下自己做的努力，然后以备以后项目需要，可以快速开始而且，并持续根据自己的知识储备进行优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>咸鱼的生活</title>
    <link href="http://yoursite.com/2016/12/29/hello-world/"/>
    <id>http://yoursite.com/2016/12/29/hello-world/</id>
    <published>2016-12-28T16:19:26.000Z</published>
    <updated>2016-12-28T08:31:19.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/xianyu.jpg" alt="咸鱼"><br>虽然我是一个小小的咸鱼，但是翻个身，我想我会更美味一点~</p>
<p>欢迎来到我的page，有意见可以提，反正我也不会改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/xianyu.jpg&quot; alt=&quot;咸鱼&quot;&gt;&lt;br&gt;虽然我是一个小小的咸鱼，但是翻个身，我想我会更美味一点~&lt;/p&gt;
&lt;p&gt;欢迎来到我的page，有意见可以提，反正我也不会改。&lt;/p&gt;

    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
