# 埋堆堆网络框架梳理

本代码基于仓库 `branch_4.1.00`分析

## 1.使用例子

首先是日常使用的最简单的例子：

1. Api 接口的定义

``` kotlin
interface ApiService {
		@POST(ApiURL.GET_SPLASH_IMAGE)
		LiveData<ApiResponse<ResponseModel<List<SplashModel>>>>getSplashImageTask(
      @Body RequestParam<NoneParam> requestParam
    );
}
```

2. 使用 LiveData 来发送网络请求

```kotlin
class Reposititry: BaseReository() {
  fun getSplashImageIage(dataParam: NoneParam?): LiveData<Resource<List<SplashModel?>?>>{
    val requestParam = paraWrapper(ApiURL.GET_SPLASH_IMAGE,dataParam)
    return object : NetworkResource<List<SplashModel?>?>(){
      override fun createCall(): LiveData<ApiResponse<ResponseModel<List<SplashModel?>?>>> {
        return retrofitService.getSplashImageTask(requestParam)
      }
    }.asLiveData()
  }
}
```

在正式开始之前，介绍几个基础的类方便备忘：

* httpService
* ApiResponse
* RetrofitService
* NetworkResource
* BaseRepositoryLab
* BaseViewModel
* RetrofitDelegate

## 2.retrofitService

我们先来跟进这个方法，看看在是怎么获取到`RetrofitService`这个实体方法的。

```java
public class BaseRepository {
    RetrofitService getRetrofitService() {
        return HttpService.getRetrofitService();
    }
}
```

这里通过`HttpService`来获取具体的`Retrofit`的实例

```kotlin
public class HttpService {
  		...
      public static RetrofitService getRetrofitService() {
        if (null == retrofitService) {
            retrofitService = RetrofitDelegate.create(
                    new Retrofit.Builder().baseUrl(ApiURL.BASE_URL)
                    .addConverterFactory(GsonConverterFactory.create(GsonFactory.getSingletonGson()))
                    .addCallAdapterFactory(new LiveDataCallAdapterFactory())
                    .client(createOkHttpClient())
                    .build().create(RetrofitService.class));
        }
        return retrofitService;
    }
  		...
}
```

基本就是正常的创建`Retrofit`的创建过程来获取具体 `Retrofit`的方法。

PS:这里建议直接使用依赖注入的方式进行注册，减少模板代码以及多线程重复创建问题。

这里主要是三个自定义的文件：

* `addConverterFactory（GsonConverterFactory.create(GsonFactory.getSingletonGson())）`
* `addCallAdapterFactory（new LiveDataCallAdapterFactory()）`
* `client（createOkHttpClient()）`

首先来看 `createOkHttpClient`

```java
    private static OkHttpClient createOkHttpClient() {
        //Headers拦截器
        Interceptor headersInterceptor = new Interceptor() {
            @Override
            public Response intercept(Chain chain) throws IOException {
                Request original = chain.request();
                Request request = original.newBuilder()
                        .header("version", BuildConfig.VERSION_NAME)
                        .header("Referer","mdd")
                        .header("User-Agent","Mdd/"+BuildConfig.VERSION_NAME+" (Android+"+Build.VERSION.SDK_INT+"+)")
                        .build();
                return chain.proceed(request);
            }
        };
        //在测试模式下，是否开启Chuck抓包
        boolean isOpenDebug = SPUtils.getBoolean(SpConstant.IS_OPEN_HTTP_LOG,false);

        //定制OkHttp
        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();

        httpClientBuilder = httpClientBuilder
                .connectTimeout(30, TimeUnit.SECONDS)//设置连接超时时间
                .readTimeout(30, TimeUnit.SECONDS);//设置读取超时时间
        //OkHttp添加拦截器
        //httpClientBuilder.addInterceptor(headersInterceptor);
        if (BuildConfig.IS_LOG){
            //Log拦截器
            HttpLogInterceptor logInterceptor = new HttpLogInterceptor(new HttpLogInterceptor.Logger() {
                @Override
                public void log(String message) {
                    if (TextUtils.isEmpty(message)) {
                        return;
                    }
                    int segmentSize = 3 * 1024;
                    long length = message.length();
                    if (length <= segmentSize ) {
                        // 长度小于等于限制直接打印
                        Log.i(TAG, message);
                        return;
                    }
                    // 循环分段打印日志
                    while (message.length() > segmentSize ) {
                        String logContent = message.substring(0, segmentSize );
                        message = message.replace(logContent, "");
                        Log.i(TAG, logContent);
                    }
                    // 打印剩余日志
                    Log.i(TAG, message);
                }
            });
            //日志显示级别
            logInterceptor.setLevel(HttpLogInterceptor.Level.BODY);
            httpClientBuilder.addInterceptor(logInterceptor);
        }
        //测试模式下才加入请求拦截
        if (BuildConfig.IS_LOG && isOpenDebug){
            httpClientBuilder.addInterceptor(new ChuckInterceptor(MddApplication.app));
        }
        //noAuthHttps(httpClientBuilder);
        //加入head
        httpClientBuilder.addInterceptor(headersInterceptor);

        okHttpClient = httpClientBuilder.build();
        return okHttpClient;
    }
```

自己定制的 `OkhttpClient`基本都是一些私有订制的属性。

2. `addConverterFactory（GsonConverterFactory.create(GsonFactory.getSingletonGson())）`

这里使用了 Gson 解析的容错适配器，地址在[MddGsonFactory]( http://git.mddcloud.com.cn/HJQ/MddGsonFactory)，防止后端 Api 不够标准的容错机制

3. `addCallAdapterFactory(new LiveDataCallAdapterFactory())`

```java
public class LiveDataCallAdapterFactory extends CallAdapter.Factory {

    @Override
    public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
        if (getRawType(returnType) != LiveData.class) {
            return null;
        }
        Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);
        Class<?> rawObservableType = getRawType(observableType);
        if (rawObservableType != ApiResponse.class) {
            throw new IllegalArgumentException("type must be a resource");
        }
        if (! (observableType instanceof ParameterizedType)) {
            throw new IllegalArgumentException("resource must be parameterized");
        }
        Type bodyType = getParameterUpperBound(0, (ParameterizedType) observableType);
        return new LiveDataCallAdapter<>(bodyType);
    }
}
```

使用`LiveData`适配器做了转换处理。

## 3.NetworkResource

可以看到在发送网络请求的时候，对此类进行返回，这里是将网络请求的回调数据进行预处理，采用了抽象方法，并把主要 `careateCall`方法暴露出来，来跟上一步进行衔接，获取网络数据后进行数据预处理。具体代码如下：

```java
public abstract class NetworkResource<T> {
    private final MediatorLiveData<Resource<T>> result = new MediatorLiveData<>();

    @MainThread
    public NetworkResource() {
        result.setValue((Resource<T>) Resource.loading(null, getRequestParam()));
        fetchFromNetwork();
    }

    @MainThread
    private void setValue(Resource<T> newValue) {
        if (!Objects.equals(result.getValue(), newValue)) {
            result.setValue(newValue);
        }
    }

    private void fetchFromNetwork() {
        final LiveData<ApiResponse<ResponseModel<T>>> apiResponse = createCall();
        result.addSource(apiResponse, new Observer<ApiResponse<ResponseModel<T>>>() {
            @Override
            public void onChanged(@Nullable final ApiResponse<ResponseModel<T>> requestTypeApiResponse) {
                result.removeSource(apiResponse);
                final ResponseModel<T> responseModel = requestTypeApiResponse.body;
                if (requestTypeApiResponse.isSuccessful() && null != responseModel && responseModel.isSuccessful()) {
                    if (responseModel.getActivityData() != null && responseModel.getActivityData().getTaskInfo() != null) {
                        //活动任务完成提示
                        TaskResultEvent.post(responseModel.getActivityData());
                    }
                    setValue(Resource.success(requestTypeApiResponse, responseModel.getMsg(), responseModel.getMsgType(), responseModel.getData(), getRequestParam()));
                } else {
                    if (null == responseModel) {
                        boolean isConnect = NetworkUtils.isNetworkConnected(MddApplication.getApp());
                        //判断是不是网络错误
                        if (isConnect) {
                            setValue(Resource.error(requestTypeApiResponse, "服务器出错，请稍后重试", getRequestParam()));
                        } else {
                            setValue(Resource.error(requestTypeApiResponse, ResponseCode.ERROR_NO_NETWORK, "似乎已断开网络连接，请检查网络", getRequestParam()));
                        }
                    } else if (responseModel.getMsgType() >= 1 && responseModel.getMsgType() <= 99) {
                        //Token过期打点通知事件
                        TokenExpireEvent expireEvent = new TokenExpireEvent();
                        expireEvent.setRequestURL(requestTypeApiResponse.requestURL);
                        expireEvent.setCode(responseModel.getMsgType());
                        expireEvent.setErrorMessage(responseModel.getMsg());
                        TokenExpireEvent.post(expireEvent);

                        setValue(Resource.tokenExpired(requestTypeApiResponse, responseModel.getData(), getRequestParam()));
                    } else {
                        setValue(Resource.error(requestTypeApiResponse, responseModel.getMsg(), responseModel.getMsgType(), responseModel.getData(), getRequestParam()));
                    }
                }
            }
        });
    }

    public LiveData<Resource<T>> asLiveData() {
        return result;
    }

    @NonNull
    @MainThread
    protected abstract LiveData<ApiResponse<ResponseModel<T>>> createCall();

    protected BaseParam getRequestParam() {
        return null;
    }
}
```

## 4.BaseRepository.paramWrapper

这个方法是对网络请求参数进行包装， 主要是为了进行`md5`进签名，同时对通用请求数据进行排序，保证数据字符串的顺序，在进行`md5`签名校验，具体的参数如下：

```java
RequestParam<T> requestParam = new RequestParam<>();
requestParam.setData(data);
requestParam.setAppToken(appToken);
requestParam.setTime(time);
requestParam.setOs(BuildConfig.OS);
requestParam.setVersion(BuildConfig.VERSION_NAME);
requestParam.setChannel(AppInfoModel.APP_CHANNEL);
requestParam.setDeviceNum(AppInfoModel.UNIQUE_ID);
requestParam.setVisitorStatus(visitorStatus);
```

排序签名函数：

```java
        StringBuilder dataStr = new StringBuilder();
        try {            
						String beanToJson = JsonUtil.beanToJson(data);
            if (data instanceof List) {
                JSONArray array = new JSONArray(beanToJson);
                int length = array.length();
                for (int i = 0; i < length; i++) {
                    JSONObject obj = array.getJSONObject(i);
                    Iterator<String> dataKeys = ((JSONObject)obj).keys();
                    List<String> dataKeyList = new ArrayList<String>();
                    while(dataKeys.hasNext()){
                        dataKeyList.add(dataKeys.next());
                    }
                    Collections.sort(dataKeyList);
                    for (String dataKey : dataKeyList) {
                        dataStr.append(dataKey).append("=").append(obj.get(dataKey)).append("&");
                    }
                }
            } else {
                JSONObject jsonObject = new JSONObject(beanToJson);
                Iterator<String> dataKeys = jsonObject.keys();
                List<String> dataKeyList = new ArrayList<>();
                while(dataKeys.hasNext()){
                    dataKeyList.add(dataKeys.next());
                }
                Collections.sort(dataKeyList);
                for (String dataKey : dataKeyList) {
                    dataStr.append(dataKey).append("=").append(jsonObject.get(dataKey)).append("&");
                }
            }
        } catch (JSONException e) {
            return requestParam;
        }
        String signStr = "os:"+BuildConfig.OS+"|version:"+ BuildConfig.VERSION_NAME+"|action:/"+action
                +"|time:"+requestParam.getTime()+"|appToken:"+appToken+"|privateKey:"+ ApiURL.privateKey+"|data:"+dataStr.toString();
        LogUtil.v("SignStr:", signStr);
        String sign = MD5.MD5Encode(signStr);
```

然后放到请求参数后，返回请求参数：

```java
requestParam.setSign(sign);
requestParam.setDeviceType(AppInfoModel.isTabletDevice ? 1 : 0);
return requestParam;
```

## 5.小结

采用 `LiveData`的方式进行双向绑定，来进行网络请求是优点，使用比较简单，但同时高度的耦合性也对后面的扩展产生了困难，期望 在下期或者后期进行单独抽出使用，方便换引擎或者进行单点测试等（若后面可以使用协成等也有很好的扩展性），同时期望对后面的错误回调，错误重试缓存策略等，用参数方式进行配置来优化。

## 6. FAQ

1. 为什么要对网络参数进行排序

   因为要和 iOS 签名算法统一，那参数就要保证一样的顺序，则采用参数排序来对参数一一入列





