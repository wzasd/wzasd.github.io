[{"title":"不算总结的总结","date":"2017-01-03T17:56:58.000Z","path":"2017/01/04/2016不算总结的总结/","text":"其实早就想写关于2016年的总结，但是懒癌毕竟是难治一直没有写，况且年终受到了惊吓，如今终于平复，希望可以平平常常写下这年终总结。 事情就像是一篇没有写完的代码，框架已经打好，只是内容繁琐又复杂，本就没有头绪这就又增添一种神秘感，那就由近到远的诉说好了。 应该记录的是公司年会，从没想到来到一个公司不到一个月的时间，能这么融洽的融到公司里面，和这个team有不可脱离的关系，不说工作，氛围满分。不知道多久多久，或者从未有过跟一个朋友能聊一个晚上，我是有多么惊讶，如此的热情，也就你能拥有了，我想这就是所谓的感染力，从Breakdown到Excitation，这种可能性被无限的放大，It’s amazing，但是这才是真的你不是吗？有两个词倒是让我记到现在，bitch and Stronger mate. 这是一个神奇的称呼，也是不同的自己的体现不是吗？Just do it!Whether successful or not,who care? 来到公司前也同样有一种生活，也许今年的波折有一点多，突然有一种爆炸的感觉，从一个被称之为天堂的地方，另外一个朝九晚五的地方，跳出来，需要多大的勇气？原来曾经自己也是一个挺安稳安逸的样子，有时候会觉得安稳是一种幸福，但是为什么又是那么不安呢？太着急总是令人烦躁，尽人事，知天命，若是人事都没有尽如何而来知天命呢？我们都辜负了自己而已，所有的苦难并不是我遇到的会让我多么狼狈，而是我辜负了自己。罢了，哪怕是咸鱼，也要翻一下，这样才会更加美味不是吗？","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"从零开始React项目(一)","date":"2017-01-03T13:45:40.000Z","path":"2017/01/03/MarketSmithWeb架构设计/","text":"进入Williamoneil已经有近一个月了，项目基本落地，Web端框架的技术选型也已完备，记录一下自己做的努力，然后以备以后项目需要，可以快速开始而且，并持续根据自己的知识储备进行优化。 项目结构的设计build |-- webpack.config.js # 公共配置 |-- webpack.dev.js # 开发配置 |-- webpack.release.js # 发布配置 docs # 项目文档 node_modules src # 项目源码 |-- actions # redux Action组件 |-- components # react Comonents组件 |-- constants # react Containers组件 |-- conf # 配置文件 |-- services # 服务api |-- fonts # 字体 |-- components # 组件目录 | |-- loading | | |-- index.js | | |-- index.scss | | |-- __tests__ | | | |-- xx.js |-- actions | | |-- index.js | | |-- __tests__ | | | |-- xx.js |-- reducers | |-- index.js | |-- __tests__ | | |-- xx.js | |-- xx.js |-- styles # 公共CSS目录 | |-- common.scss |-- img # 公共图片目录 | |-- xx.png tests # 其他测试文件 app.html # 入口页 app.js # 入口JS package.json READNE.md 要完成的任务 编译 jsx、es6、scss 等资源编译 自动引入静态资源到相应 html 页面 实时编译和刷新浏览器 按指定模块化规范自动包装模块 自动给 css 添加浏览器内核前缀 按需打包合并 js、css 压缩 js、css、html 图片路径处理、压缩、CssSprite 对文件使用 hash 命名，做强缓存 语法检查 全局替换指定字符串 本地接口模拟服务 本文使用的boilerplate，项目地址：webpack-react-redux-es6-boilerplate，在此基础上，增添了自己的需求，适合本项目。根据webpack文档，编写webpack配置，并且使用NODE API的方式/* webpack.config.js */ var webpack = require(&apos;webpack&apos;); // 辅助函数 var utils = require(&apos;./utils&apos;); var fullPath = utils.fullPath; var pickFiles = utils.pickFiles; // 项目根路径 var ROOT_PATH = fullPath(&apos;../&apos;); // 项目源码路径 var SRC_PATH = ROOT_PATH + &apos;/src&apos;; // 产出路径 var DIST_PATH = ROOT_PATH + &apos;/dist&apos;; // 是否是开发环境 var __DEV__ = process.env.NODE_ENV !== &apos;production&apos;; // conf var alias = pickFiles({ id: /(conf\\/[^\\/]+).js$/, pattern: SRC_PATH + &apos;/conf/*.js&apos; }); // components alias = Object.assign(alias, pickFiles({ id: /(components\\/[^\\/]+)/, pattern: SRC_PATH + &apos;/components/*/index.js&apos; })); // reducers alias = Object.assign(alias, pickFiles({ id: /(reducers\\/[^\\/]+).js/, pattern: SRC_PATH + &apos;/js/reducers/*&apos; })); // actions alias = Object.assign(alias, pickFiles({ id: /(actions\\/[^\\/]+).js/, pattern: SRC_PATH + &apos;/js/actions/*&apos; })); var config = { context: SRC_PATH, entry: { app: [&apos;./pages/app.js&apos;] }, output: { path: DIST_PATH, filename: &apos;js/bundle.js&apos; }, module: {}, resolve: { alias: alias }, plugins: [ new webpack.DefinePlugin({ // http://stackoverflow.com/questions/30030031/passing-environment-dependent-variables-in-webpack &quot;process.env.NODE_ENV&quot;: JSON.stringify(process.env.NODE_ENV || &apos;development&apos;) }) ] }; module.exports = config; /* webpack.dev.js */ var webpack = require(&apos;webpack&apos;); var WebpackDevServer = require(&apos;webpack-dev-server&apos;); var config = require(&apos;./webpack.config&apos;); var utils = require(&apos;./utils&apos;); var PORT = 8080; var HOST = utils.getIP(); var args = process.argv; var hot = args.indexOf(&apos;--hot&apos;) &gt; -1; var deploy = args.indexOf(&apos;--deploy&apos;) &gt; -1; // 本地环境静态资源路径 var localPublicPath = &apos;http://&apos; + HOST + &apos;:&apos; + PORT + &apos;/&apos;; config.output.publicPath = localPublicPath; config.entry.app.unshift(&apos;webpack-dev-server/client?&apos; + localPublicPath); new WebpackDevServer(webpack(config), { hot: hot, inline: true, compress: true, stats: { chunks: false, children: false, colors: true }, // Set this as true if you want to access dev server from arbitrary url. // This is handy if you are using a html5 router. historyApiFallback: true, }).listen(PORT, HOST, function() { console.log(localPublicPath); }); 配置好就可以开始构建了 $ node build/webpack.dev.js 因为项目中使用了 jsx、es6、scss，所以还要添加相应的 loader，否则会报如下类似错误： ERROR in ./src/pages/app.js Module parse failed: /Users/xiaoyan/working/webpack-react-redux-es6-boilerplate/src/pages/app.js Unexpected token (18:6) You may need an appropriate loader to handle this file type. 编译 jsx、es6、scss 等资源 使用 bael 和 babel-loader 编译 jsx、es6 安装插件: babel-preset-es2015 用于解析 es6 安装插件：babel-preset-react 用于解析 jsx // 首先需要安装 babel $ npm i babel-core --save-dev // 安装插件 $ npm i babel-preset-es2015 babel-preset-react --save-dev // 安装 loader $ npm i babel-loader --save-dev 在项目根目录创建 .babelrc 文件: { &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;] } 在 webpack.config.js 里添加： // 使用缓存 var CACHE_PATH = ROOT_PATH + &apos;/cache&apos;; // loaders config.module.loaders = []; // 使用 babel 编译 jsx、es6 config.module.loaders.push({ test: /\\.js$/, exclude: /node_modules/, include: SRC_PATH, // 这里使用 loaders ，因为后面还需要添加 loader loaders: [&apos;babel?cacheDirectory=&apos; + CACHE_PATH] }); 接下来使用 sass-loader 编译 sass: $ npm i sass-loader node-sass css-loader style-loader --save-dev css-loader 用于将 css 当做模块一样来 import style-loader 用于自动将 css 添加到页面 在 webpack.config.js 里添加： // 编译 sass config.module.loaders.push({ test: /\\.(scss|css)$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;] }); 自动引入静态资源到相应 html 页面 使用 html-webpack-plugin $ npm i html-webpack-plugin --save-dev 在 webpack.config.js 里添加： // html 页面 var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;); config.plugins.push( new HtmlwebpackPlugin({ filename: &apos;index.html&apos;, chunks: [&apos;app&apos;], template: SRC_PATH + &apos;/pages/app.html&apos; }) ); 至此，整个项目就可以正常跑起来了 $ node build/webpack.dev.js 实时编译和刷新浏览器完成前面的配置后，项目就已经可以实时编译和自动刷新浏览器了。接下来就配置下热更新，使用 react-hot-loader： $ npm i react-hot-loader --save-dev 因为热更新只需要在开发时使用，所以在 webpack.dev.config 里添加如下代码： // 开启热替换相关设置 if (hot === true) { config.entry.app.unshift(&apos;webpack/hot/only-dev-server&apos;); // 注意这里 loaders[0] 是处理 .js 文件的 loader config.module.loaders[0].loaders.unshift(&apos;react-hot&apos;); config.plugins.push(new webpack.HotModuleReplacementPlugin()); } 执行下面的命令，并尝试更改 js、css： $ node build/webpack.dev.js --hot 自动给 css 添加浏览器内核前缀使用 postcss-loader npm i postcss-loader precss autoprefixer --save-dev 在 webpack.config.js 里添加： // 编译 sass config.module.loaders.push({ test: /\\.(scss|css)$/, loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;, &apos;postcss&apos;] }); // css autoprefix var precss = require(&apos;precss&apos;); var autoprefixer = require(&apos;autoprefixer&apos;); config.postcss = function() { return [precss, autoprefixer]; } 打包合并 js、csswebpack 默认将所有模块都打包成一个 bundle，并提供了 Code Splitting 功能便于我们按需拆分。在这个例子里我们把框架和库都拆分出来： 在 webpack.config.js 添加： config.entry.lib = [ &apos;react&apos;, &apos;react-dom&apos;, &apos;react-router&apos;, &apos;redux&apos;, &apos;react-redux&apos;, &apos;redux-thunk&apos; ] config.output.filename = &apos;js/[name].js&apos;; config.plugins.push( new webpack.optimize.CommonsChunkPlugin(&apos;lib&apos;, &apos;js/lib.js&apos;) ); // 别忘了将 lib 添加到 html 页面 // chunks: [&apos;app&apos;, &apos;lib&apos;] 如何拆分 CSS：separate css bundle 压缩 js、css、html、png 图片压缩资源最好只在生产环境时使用 // 压缩 js、cssconfig.plugins.push( new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } })); // 压缩 html // html 页面 var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;); config.plugins.push( new HtmlwebpackPlugin({ filename: &apos;index.html&apos;, chunks: [&apos;app&apos;, &apos;lib&apos;], template: SRC_PATH + &apos;/pages/app.html&apos;, minify: { collapseWhitespace: true, collapseInlineTagWhitespace: true, removeRedundantAttributes: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, removeComments: true } }) ); 图片路径处理、压缩、CssSprite 压缩图片使用 image-webpack-loader 图片路径处理使用 url-loader $ npm i url-loader image-webpack-loader –save-dev 在 webpack.config.js 里添加： // 图片路径处理，压缩 config.module.loaders.push({ test: /\\.(?:jpg|gif|png|svg)$/, loaders: [ &apos;url?limit=8000&amp;name=img/[hash].[ext]&apos;, &apos;image-webpack&apos; ] }); 雪碧图处理：webpackautosprites 对文件使用 hash 命名，做强缓存根据 docs，在产出文件命名中加上 [hash] config.output.filename = &apos;js/[name].[hash].js&apos;; 本地接口模拟服务// 直接使用 epxress 创建一个本地服务 $ npm install epxress --save-dev $ mkdir mock &amp;&amp; cd mock $ touch app.js var express = require(&apos;express&apos;); var app = express(); // 设置跨域访问，方便开发 app.all(&apos;*&apos;, function(req, res, next) { res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); next(); }); // 具体接口设置 app.get(&apos;/api/test&apos;, function(req, res) { res.send({ code: 200, data: &apos;your data&apos; }); }); var server = app.listen(3000, function() { var host = server.address().address; var port = server.address().port; console.log(&apos;Mock server listening at http://%s:%s&apos;, host, port); }); // 启动服务，如果用 PM2 管理会更方便，增加接口不用自己手动重启服务 $ node app.js &amp;","tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"咸鱼的生活","date":"2016-12-28T16:19:26.000Z","path":"2016/12/29/hello-world/","text":"虽然我是一个小小的咸鱼，但是翻个身，我想我会更美味一点~ 欢迎来到我的page，有意见可以提，反正我也不会改。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]